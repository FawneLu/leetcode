### BFS
这道题用一个BFS, 把rotten的橘子的位置放在队列里。用一个循坏来判断上一次添加几个橘子。  
每次循环结束step+1。  
首先统计新鲜橘子的个数，把腐败橘子的位置保存到队列中。

然后遍历队列，每一步中，把队列中已经有的所有腐败橘子都弹出来，判断它的四周有没有新鲜橘子，然后把新鲜橘子变成腐败的，并把该位置放到队列中，同时还要把新鲜橘子的个数-1.

当我们走到某一个时间之后，发现队列中没有腐败的橘子了。这个时候意味着在上一步中，没有新鲜橘子被传染成腐败的，即无路可走了。这个时候，我们停止。

停止之后，需要根据新鲜橘子的个数是不是已经全部被染成了腐败的来判断是不是返回-1.如果全部被染了，需要返回的是step - 1，为什么不是step呢？因为我们在对队列的第一次循环过程中，遍历了题目给出的腐败橘子，这个也统计到了step中，所以比要经历的时间多了1次，因此减去。
