对于一个节点（当然先从JFK开始)，贪心地访问最小的邻居，访问过的边全部删除。当碰到死路的时候就回溯到最近一个还有出路的节点，然后把回溯的路径放到最后去访问，这个过程和后序遍历的一样。1. 如果子节点没有死路（每个节点都只左子树），前序遍历便是欧拉路径。2. 如果子节点1是死路，子节点2完成了遍历，那么子节点2先要被访问。1，2都和后序遍历的顺序正好相反。

其中，如果碰到死路，而没有把所有的边都走过一遍的话，就说明这种走法不满足itinerary，需要沿着树根向上找到最近的一个有其他路可以走的节点N，把新的路走一遍。因为题目保证一定存在一条满足要求的itinerary路径，那么一条这样的死路，一定会相对的在这个节点N上存在另一条路，这条路存在一个回到该节点N的环。先把这个环走过之后再去走这条死路，就可以保证把以N为树根的这个路径上的所有点都走到。

首先肯定是要把路径保存成链表法表示的图的。然后对每个顶点的所有邻接顶点进行排序，这样我们每次都优先选择字典序最小的那个顶点作为下次遍历的节点。我们做了后序遍历即可。最后还要把后序遍历的结果再翻转，才是从根节点出发到每个位置的路径。
