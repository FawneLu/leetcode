### 求非叶子节点的和的最小值
- 单调递减栈  
每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积，也就是说，一个较大的数和一个较小的数乘积会消耗一个较小的数余下一个较大的数。那么我们就有一个贪心的策略，每次最小的两个数相乘最后将乘积相加，那么和一定是最小的。对于上面这个例子[6, 2, 4]来说，我们需要找2两边比2大的最小的数4。
- recursion+优化  
树型问题首先思考递归，这个问题可以通过递归加记忆化搜索处理。我们可以定义函数f(i,j)f(i,j)f(i,j)返回区间arr[i:j+1]内的非叶节点的值的最小可能总和，那么不难写出递归方程  
f(i,j)=min(f(i,j),f(i,k−1)+f(k,j)+max(arr[i:k])∗max(arr[k:j+1]))  
也就是通过k将区间分成两个部分，然后对两部分分别递归即可。边界条件也非常简单，当i>=j的时候，返回0即可。
