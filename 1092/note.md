### dp
动态规划  
设dp[i + 1][j + 1]为str1[0 , i] 和str2[0 , j]的最短公共超序列 的长度；  

当str1[i] == str2[j]时，dp[i + 1][j + 1] = dp[i][j] + 1 ；  

当str1[i] ！= str2[j]时， 判断谁是最短公共超序列的最后一个字符，如果是str1[i]，那么dp[i + 1][j + 1] = dp[i][j + 1] + 1  ;  

如果是str2[j] , 那么dp[i + 1][j + 1] = dp[i + 1][j ] + 1  ;  

然后根据dp[i+1][j + 1]的关系，逆序将字符连接到res中；  
